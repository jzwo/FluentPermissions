using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace FluentPermissions;

internal static class SourceBuilders
{
    private const string RootCode = "APP";

    public static string BuildModels(Model model)
    {
        var ns = GetRootNamespace(model.Compilation);
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine($"namespace {ns}.Security;");
        sb.AppendLine();
        sb.AppendLine("public sealed class PermissionDescriptor");
        sb.AppendLine("{");
        sb.AppendLine("    public string Code { get; }");
        sb.AppendLine("    public string Name { get; }");
        sb.AppendLine("    public string? DisplayName { get; }");
        sb.AppendLine("    public string Parent { get; }");
        sb.AppendLine("    public bool IsLeaf { get; }");
        sb.AppendLine("    public bool IsGroup => !IsLeaf;");
        sb.AppendLine("    public string DisplayOrName => DisplayName ?? Name;");
        sb.AppendLine();
        sb.AppendLine("    public PermissionDescriptor(string code, string name, string? displayName, string parent, bool isLeaf)");
        sb.AppendLine("    {");
        sb.AppendLine("        Code = code;");
        sb.AppendLine("        Name = name;");
        sb.AppendLine("        DisplayName = displayName;");
        sb.AppendLine("        Parent = parent;");
        sb.AppendLine("        IsLeaf = isLeaf;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    public static string BuildApp(Model model)
    {
        var ns = GetRootNamespace(model.Compilation);
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine($"namespace {ns}.Security;");
        sb.AppendLine();
        sb.AppendLine("public static partial class Permissions");
        sb.AppendLine("{");

        foreach (var g in model.RootGroups)
            EmitFlatConstants(sb, g, null, RootCode, 4);

        sb.AppendLine();
        sb.AppendLine("    public static readonly global::System.Collections.Generic.IReadOnlyList<PermissionDescriptor> All = new PermissionDescriptor[]");
        sb.AppendLine("    {");
        foreach (var g in model.RootGroups)
            EmitDescriptors(sb, g, RootCode, 8);
        sb.AppendLine("    };");
        sb.AppendLine();
        sb.AppendLine("    public static readonly global::System.Collections.Generic.IReadOnlyDictionary<string, PermissionDescriptor> ByCode = BuildByCode();");
        sb.AppendLine("    public static readonly global::System.Collections.Generic.IReadOnlyList<string> AllCodes = BuildAllCodes();");
        sb.AppendLine();
        sb.AppendLine("    public static bool Contains(string code) => ByCode.ContainsKey(code);");
        sb.AppendLine("    public static bool TryGet(string code, out PermissionDescriptor? descriptor) => ByCode.TryGetValue(code, out descriptor);");
        sb.AppendLine("    public static PermissionDescriptor GetByCode(string code) => ByCode[code];");
        sb.AppendLine("    public static global::System.Collections.Generic.IReadOnlyList<string> GetAllCodes() => AllCodes;");
        sb.AppendLine("    public static global::System.Collections.Generic.IReadOnlyList<PermissionDescriptor> GetLeaves()");
        sb.AppendLine("    {");
        sb.AppendLine("        var list = new global::System.Collections.Generic.List<PermissionDescriptor>();");
        sb.AppendLine("        foreach (var item in All)");
        sb.AppendLine("            if (item.IsLeaf)");
        sb.AppendLine("                list.Add(item);");
        sb.AppendLine("        return list;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static global::System.Collections.Generic.IReadOnlyList<PermissionDescriptor> GetChildren(string parentCode)");
        sb.AppendLine("    {");
        sb.AppendLine("        var list = new global::System.Collections.Generic.List<PermissionDescriptor>();");
        sb.AppendLine("        foreach (var item in All)");
        sb.AppendLine("            if (global::System.StringComparer.Ordinal.Equals(item.Parent, parentCode))");
        sb.AppendLine("                list.Add(item);");
        sb.AppendLine("        return list;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private static global::System.Collections.Generic.IReadOnlyDictionary<string, PermissionDescriptor> BuildByCode()");
        sb.AppendLine("    {");
        sb.AppendLine("        var dict = new global::System.Collections.Generic.Dictionary<string, PermissionDescriptor>(global::System.StringComparer.Ordinal);");
        sb.AppendLine("        foreach (var item in All)");
        sb.AppendLine("            dict[item.Code] = item;");
        sb.AppendLine("        return new global::System.Collections.ObjectModel.ReadOnlyDictionary<string, PermissionDescriptor>(dict);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private static global::System.Collections.Generic.IReadOnlyList<string> BuildAllCodes()");
        sb.AppendLine("    {");
        sb.AppendLine("        var list = new global::System.Collections.Generic.List<string>(All.Count);");
        sb.AppendLine("        foreach (var item in All)");
        sb.AppendLine("            list.Add(item.Code);");
        sb.AppendLine("        return list;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static void EmitFlatConstants(StringBuilder sb, GroupDef g, string? parentPath, string parentCode, int indent)
    {
        var path = parentPath is null ? g.LogicalName : parentPath + "_" + g.LogicalName;
        var code = parentCode + ":" + g.LogicalName;
        var pad = new string(' ', indent);
        if (g.IncludeSelfAsPermission)
            sb.AppendLine(pad + $"public const string {SafeIdent(path)} = \"{code}\";");

        foreach (var c in g.Children)
            EmitFlatConstants(sb, c, path, code, indent);

        foreach (var p in g.Permissions)
        {
            var permPath = path + "_" + p.LogicalName;
            var permCode = code + ":" + p.LogicalName;
            sb.AppendLine(pad + $"public const string {SafeIdent(permPath)} = \"{permCode}\";");
        }
    }

    private static void EmitDescriptors(StringBuilder sb, GroupDef g, string parentCode, int indent)
    {
        var groupCode = parentCode + ":" + g.LogicalName;
        var pad = new string(' ', indent);
        var groupDisplay = string.Equals(g.DisplayName, g.LogicalName) || g.DisplayName is null
            ? "null"
            : ToLiteral(g.DisplayName);

        if (g.IncludeSelfAsPermission)
            sb.AppendLine(pad + $"new PermissionDescriptor(\"{groupCode}\", \"{g.LogicalName}\", {groupDisplay}, \"{parentCode}\", false),");

        foreach (var c in g.Children)
            EmitDescriptors(sb, c, groupCode, indent);

        foreach (var p in g.Permissions)
        {
            var pCode = groupCode + ":" + p.LogicalName;
            var pDisplay = string.Equals(p.DisplayName, p.LogicalName) || p.DisplayName is null
                ? "null"
                : ToLiteral(p.DisplayName);
            sb.AppendLine(pad + $"new PermissionDescriptor(\"{pCode}\", \"{p.LogicalName}\", {pDisplay}, \"{groupCode}\", true),");
        }
    }

    private static string ToLiteral(string s)
    {
        return "\"" + PermissionSourceGenerator.EscapeString(s) + "\"";
    }

    private static string GetRootNamespace(Compilation compilation)
    {
        var asm = compilation.AssemblyName ?? "FluentPermissions";
        var valid = new string(asm.Where(ch => char.IsLetterOrDigit(ch) || ch == '_' || ch == '.').ToArray());
        if (string.IsNullOrWhiteSpace(valid)) valid = "FluentPermissions";
        return valid;
    }

    private static string SafeIdent(string name)
    {
        var sb = new StringBuilder(name.Length);
        foreach (var ch in name)
            sb.Append(char.IsLetterOrDigit(ch) || ch == '_' ? ch : '_');
        if (sb.Length == 0 || (!char.IsLetter(sb[0]) && sb[0] != '_')) sb.Insert(0, '_');
        return sb.ToString();
    }
}
